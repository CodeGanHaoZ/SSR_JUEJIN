import o, { useRef as s, useEffect as J } from "react";
import t from "prop-types";
import { json as x, jsonParseLinter as H } from "@codemirror/lang-json";
import { useCodeMirror as L } from "@uiw/react-codemirror";
import { Field as T } from "../Field/Field.js";
import { FieldLabel as P } from "../Field/FieldLabel.js";
import "../Field/FieldInput.js";
import { FieldHint as R } from "../Field/FieldHint.js";
import { FieldError as j } from "../Field/FieldError.js";
import "../Field/FieldContext.js";
import "../Field/FieldAction.js";
import { Stack as q } from "../Stack/Stack.js";
import { JSONInputContainer as z } from "./JSONInputContainer.js";
import { markField as B, addMarks as _, lineHighlightMark as w, filterMarks as V } from "./utils/decorationExtension.js";
const E = ({ label: u, value: b, error: d, hint: S, required: C, onChange: k, disabled: f, labelAction: O, ...F }) => {
  const i = s(), c = s(null), l = s(null), m = Boolean(d), v = (e) => c.current?.doc?.line(e), y = (e) => {
    const { text: r, to: n } = v(e), a = n - r.trimStart().length;
    n > a && l.current?.dispatch({
      effects: _.of([w.range(a, n)])
    });
  }, M = () => {
    const e = c.current?.doc?.length || 0;
    l.current?.dispatch({
      effects: V.of((r, n) => n <= 0 || r >= e)
    });
  }, h = (e) => {
    const { view: r, state: n } = e;
    l.current = r, c.current = n, M();
    const g = H()(r);
    g.length && y(n.doc.lineAt(g[0].from).number);
  }, N = (e, r) => {
    h(r), k(e);
  }, A = (e, r) => {
    l.current = e, c.current = r, h({ view: e, state: r });
  }, { setContainer: p } = L({
    value: b,
    onCreateEditor: A,
    theme: "dark",
    onChange: N,
    editable: !f,
    container: i.current,
    extensions: [x(), B],
    basicSetup: {
      lineNumbers: !0,
      bracketMatching: !0,
      closeBrackets: !0,
      indentOnInput: !0,
      syntaxHighlighting: !0,
      highlightSelectionMatches: !0,
      tabSize: 2,
      defaultCharacterWidth: 5
    }
  }), I = () => {
    f || i.current.children[0].children[1].children[1].focus();
  };
  return J(() => {
    const e = i.current;
    e && p(e);
  }, [p, m]), /* @__PURE__ */ o.createElement(T, {
    error: d,
    hint: S,
    required: C
  }, /* @__PURE__ */ o.createElement(q, {
    spacing: 1
  }, u && /* @__PURE__ */ o.createElement(P, {
    onClick: I,
    action: O
  }, u), /* @__PURE__ */ o.createElement(z, {
    ref: i,
    hasError: m,
    alignItems: "stretch",
    fontSize: 2,
    hasRadius: !0,
    ...F
  }), /* @__PURE__ */ o.createElement(j, null), /* @__PURE__ */ o.createElement(R, null)));
};
E.defaultProps = {
  label: void 0,
  labelAction: void 0,
  value: "",
  error: void 0,
  hint: void 0,
  required: !1,
  disabled: !1,
  onChange() {
  }
};
E.propTypes = {
  label: t.string,
  labelAction: t.element,
  value: t.string,
  error: t.oneOfType([t.string, t.bool]),
  hint: t.oneOfType([t.string, t.node, t.arrayOf(t.node)]),
  required: t.bool,
  disabled: t.bool,
  onChange: t.func
};
export {
  E as JSONInput
};
